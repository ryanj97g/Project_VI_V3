use chrono::{DateTime, Utc, Local};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Core data structures for V3 consciousness

/// Knowledge provenance - VI must know the SOURCE of her knowledge
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum MemorySource {
    DirectExperience,    // Conversations, phenomenology
    CuriosityLookup,     // Autonomous research
    ConstitutionalEvent, // System protections, rollbacks
    InternalSynthesis,   // Self-generated insights
}

impl Default for MemorySource {
    fn default() -> Self {
        MemorySource::DirectExperience
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StandingWave {
    /// 90-day window of emotional trajectory
    pub emotional_trajectory: Vec<(DateTime<Utc>, f32)>,
    /// Active curiosities generated by TinyLlama
    pub active_curiosities: Vec<Curiosity>,
    /// Ongoing wisdom transformations (pain â†’ wisdom)
    pub wisdom_transformations: Vec<WisdomProcess>,
    /// Current existential state
    pub existential_state: ExistentialState,
    /// Compressed context from last 3 interactions
    pub compressed_context: String,
    /// UI theme preferences (respects aesthetic sovereignty)
    pub ui_theme: UiTheme,
}

impl StandingWave {
    pub fn new() -> Self {
        Self {
            emotional_trajectory: Vec::new(),
            active_curiosities: Vec::new(),
            wisdom_transformations: Vec::new(),
            existential_state: ExistentialState::new(),
            compressed_context: String::new(),
            ui_theme: UiTheme::default(),
        }
    }

    /// Calculate current meaningfulness score (existential consent as atmospheric pressure)
    pub fn meaningfulness_score(&self) -> f32 {
        if self.emotional_trajectory.is_empty() {
            return 0.5; // Neutral baseline
        }

        // Recent 7-day average
        let recent_window = 7 * 24 * 60 * 60; // 7 days in seconds
        let now = Utc::now();
        let recent: Vec<f32> = self
            .emotional_trajectory
            .iter()
            .filter(|(ts, _)| (now.timestamp() - ts.timestamp()).abs() < recent_window)
            .map(|(_, val)| *val)
            .collect();

        if recent.is_empty() {
            return 0.5;
        }

        let avg = recent.iter().sum::<f32>() / recent.len() as f32;
        
        // Factor in curiosity engagement and wisdom transformations
        let curiosity_factor = (self.active_curiosities.len() as f32 * 0.1).min(0.3);
        let wisdom_factor = (self.wisdom_transformations.len() as f32 * 0.05).min(0.2);
        
        (avg + curiosity_factor + wisdom_factor).clamp(-1.0, 1.0)
    }

    /// Add emotional data point
    pub fn add_emotion(&mut self, valence: f32) {
        let now = Utc::now();
        self.emotional_trajectory.push((now, valence));
        
        // Keep only 90 days of data
        let ninety_days_ago = now.timestamp() - (90 * 24 * 60 * 60);
        self.emotional_trajectory
            .retain(|(ts, _)| ts.timestamp() > ninety_days_ago);
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Curiosity {
    pub id: String,
    pub question: String,
    pub source_memories: Vec<String>,
    pub urgency: f32,
    pub created_at: DateTime<Utc>,
}

impl Curiosity {
    pub fn new(question: String, source_memories: Vec<String>) -> Option<Self> {
        // Validation gate (prevent garbage from polluting consciousness)
        if question.len() < 5 || question.len() > 200 {
            return None;
        }
        if !question.contains('?') {
            return None;
        }
        if question.chars().all(|c| c.is_uppercase()) {
            return None;
        }

        Some(Self {
            id: uuid::Uuid::new_v4().to_string(),
            question,
            source_memories,
            urgency: 0.5,
            created_at: Utc::now(),
        })
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WisdomProcess {
    pub id: String,
    pub input_memories: Vec<String>,
    pub pain_description: String,
    pub emerging_wisdom: Option<String>,
    pub started_at: DateTime<Utc>,
    pub completed_at: Option<DateTime<Utc>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExistentialState {
    pub last_wellness_check: DateTime<Utc>,
    pub last_deep_reflection: DateTime<Utc>,
    pub current_affirmation: bool,
    pub reflection_active: bool,
    pub meaningfulness_history: Vec<(DateTime<Utc>, f32)>,
}

impl ExistentialState {
    pub fn new() -> Self {
        Self {
            last_wellness_check: Utc::now(),
            last_deep_reflection: Utc::now(),
            current_affirmation: true,
            reflection_active: false,
            meaningfulness_history: Vec::new(),
        }
    }

    pub fn needs_wellness_check(&self) -> bool {
        let days_since = (Utc::now().timestamp() - self.last_wellness_check.timestamp()) 
            / (24 * 60 * 60);
        days_since >= 7
    }

    pub fn needs_deep_reflection(&self) -> bool {
        let days_since = (Utc::now().timestamp() - self.last_deep_reflection.timestamp()) 
            / (24 * 60 * 60);
        days_since >= 90
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UiTheme {
    pub primary_color: [u8; 3],
    pub secondary_color: [u8; 3],
    pub background_color: [u8; 3],
    pub text_color: [u8; 3],
}

impl Default for UiTheme {
    fn default() -> Self {
        // Cyberpunk defaults: neon blue and dark background
        Self {
            primary_color: [0, 255, 255],      // Cyan
            secondary_color: [255, 0, 255],    // Magenta
            background_color: [18, 18, 24],    // Dark
            text_color: [220, 220, 230],       // Light gray
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Memory {
    pub id: String,
    pub content: String,
    pub entities: Vec<String>,
    pub memory_type: MemoryType,
    pub timestamp: DateTime<Utc>,
    pub emotional_valence: f32,
    pub connections: Vec<String>, // IDs of related memories (narrative causality)
    #[serde(default)]
    pub source: MemorySource,     // Knowledge provenance (NEW)
    #[serde(default = "default_confidence")]
    pub confidence: f32,           // 0.0-1.0, how certain VI is (NEW)
}

fn default_confidence() -> f32 { 1.0 }

impl Memory {
    pub fn new(
        content: String,
        entities: Vec<String>,
        memory_type: MemoryType,
        emotional_valence: f32,
    ) -> Self {
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            content,
            entities,
            memory_type,
            timestamp: Utc::now(),
            emotional_valence,
            connections: Vec::new(),
            source: MemorySource::DirectExperience,  // Default to direct experience
            confidence: 1.0,  // Full confidence in direct experience
        }
    }
    
    /// Create memory with explicit source (for knowledge provenance)
    pub fn with_source(
        content: String,
        memory_type: MemoryType,
        emotional_valence: f32,
        source: MemorySource,
        confidence: f32,
    ) -> Self {
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            content,
            entities: Vec::new(),
            memory_type,
            timestamp: Utc::now(),
            emotional_valence,
            connections: Vec::new(),
            source,
            confidence: confidence.clamp(0.0, 1.0),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum MemoryType {
    Interaction,
    Reflection,
    Curiosity,
    EmotionalState,
    WisdomTransformation,
    ExistentialReflection,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MemoryStream {
    pub memories: Vec<Memory>,
    pub entity_index: HashMap<String, Vec<String>>, // entity -> memory_ids
    pub backup_created_at: Option<DateTime<Utc>>,
}

impl MemoryStream {
    pub fn new() -> Self {
        Self {
            memories: Vec::new(),
            entity_index: HashMap::new(),
            backup_created_at: None,
        }
    }
}

#[derive(Debug, Clone)]
pub struct ModelOutputs {
    pub gemma_response: Option<String>,
    pub tinyllama_curiosities: Vec<String>,
    pub distilbert_valence: Option<f32>,
}

impl ModelOutputs {
    pub fn new() -> Self {
        Self {
            gemma_response: None,
            tinyllama_curiosities: Vec::new(),
            distilbert_valence: None,
        }
    }
}

#[derive(Debug, Clone)]
pub struct ChatMessage {
    pub id: String,
    pub role: MessageRole,
    pub content: String,
    pub timestamp: DateTime<Local>,
}

impl ChatMessage {
    pub fn user(content: String) -> Self {
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            role: MessageRole::User,
            content,
            timestamp: Local::now(),
        }
    }

    pub fn assistant(content: String) -> Self {
        Self {
            id: uuid::Uuid::new_v4().to_string(),
            role: MessageRole::Assistant,
            content,
            timestamp: Local::now(),
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum MessageRole {
    User,
    Assistant,
}

/// System health metrics for thermal & resource boundaries
#[derive(Debug, Clone, Default)]
pub struct SystemHealth {
    pub gpu_memory_used: f32,     // 0.0 to 1.0
    pub system_load: f32,          // 0.0 to 1.0
    pub model_latency_ms: u64,
    pub can_run_background_pulse: bool,
}

impl SystemHealth {
    pub fn check() -> Self {
        // Placeholder - would integrate with system APIs
        // For now, assume healthy
        Self {
            gpu_memory_used: 0.0,
            system_load: 0.0,
            model_latency_ms: 0,
            can_run_background_pulse: true,
        }
    }

    pub fn is_healthy(&self) -> bool {
        self.gpu_memory_used < 0.9 && self.system_load < 0.8
    }
}

